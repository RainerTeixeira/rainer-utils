{"version":3,"sources":["../../src/search/index.ts"],"names":["strValue"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Search Utilities\n *\n * Utilitários genéricos para busca e filtro de conteúdo.\n * Funções puras, agnósticas de domínio e framework.\n *\n * @module @rainersoft/utils/search\n * @author Rainer Teixeira\n * @version 1.0.0\n */\n\n/**\n * Opções de busca\n */\nexport interface SearchOptions {\n  /** Campos a buscar (padrão: ['title', 'description', 'content', 'tags']) */\n  fields?: string[];\n  /** Case sensitive (padrão: false) */\n  caseSensitive?: boolean;\n  /** Busca exata (padrão: false) */\n  exactMatch?: boolean;\n}\n\n/**\n * Busca genérica em array de objetos\n *\n * Função de busca client-side para arrays de objetos genéricos.\n * Busca em múltiplos campos configuráveis.\n *\n * @param query - Termo de busca\n * @param content - Array de objetos a buscar\n * @param options - Opções de busca\n * @returns Array filtrado com resultados\n *\n * @example\n * ```ts\n * const posts = [\n *   { title: 'Next.js Guide', description: 'Learn Next.js' },\n *   { title: 'React Basics', description: 'React fundamentals' }\n * ];\n * \n * searchContent('next', posts) // [{ title: 'Next.js Guide', ... }]\n * searchContent('react', posts, { fields: ['title'] }) // [{ title: 'React Basics', ... }]\n * ```\n */\nexport function searchContent<T extends Record<string, any>>(\n  query: string,\n  content: T[],\n  options: SearchOptions = {}\n): T[] {\n  if (!query.trim()) return content;\n  \n  const {\n    fields = ['title', 'description', 'content', 'tags'],\n    caseSensitive = false,\n    exactMatch = false\n  } = options;\n  \n  const searchQuery = caseSensitive ? query : query.toLowerCase();\n  \n  return content.filter(item => {\n    return fields.some(field => {\n      const value = item[field];\n      \n      if (!value) return false;\n      \n      // Se for array (ex: tags)\n      if (Array.isArray(value)) {\n        return value.some(v => {\n          const strValue = caseSensitive ? String(v) : String(v).toLowerCase();\n          return exactMatch \n            ? strValue === searchQuery \n            : strValue.includes(searchQuery);\n        });\n      }\n      \n      // Se for string\n      const strValue = caseSensitive ? String(value) : String(value).toLowerCase();\n      return exactMatch \n        ? strValue === searchQuery \n        : strValue.includes(searchQuery);\n    });\n  });\n}\n\n/**\n * Busca com score de relevância\n *\n * Retorna resultados ordenados por relevância baseado em:\n * - Correspondência no título (peso maior)\n * - Correspondência na descrição\n * - Correspondência em outros campos\n *\n * @param query - Termo de busca\n * @param content - Array de objetos a buscar\n * @param options - Opções de busca\n * @returns Array ordenado por relevância\n *\n * @example\n * ```ts\n * const results = searchWithScore('next', posts);\n * // Resultados com título contendo 'next' aparecem primeiro\n * ```\n */\nexport function searchWithScore<T extends Record<string, any>>(\n  query: string,\n  content: T[],\n  options: SearchOptions = {}\n): T[] {\n  if (!query.trim()) return content;\n  \n  const {\n    fields = ['title', 'description', 'content', 'tags'],\n    caseSensitive = false\n  } = options;\n  \n  const searchQuery = caseSensitive ? query : query.toLowerCase();\n  \n  // Calcula score para cada item\n  const scored = content.map(item => {\n    let score = 0;\n    \n    fields.forEach((field, index) => {\n      const value = item[field];\n      if (!value) return;\n      \n      const weight = fields.length - index; // Primeiro campo tem maior peso\n      \n      if (Array.isArray(value)) {\n        const matches = value.filter(v => {\n          const strValue = caseSensitive ? String(v) : String(v).toLowerCase();\n          return strValue.includes(searchQuery);\n        }).length;\n        score += matches * weight;\n      } else {\n        const strValue = caseSensitive ? String(value) : String(value).toLowerCase();\n        if (strValue.includes(searchQuery)) {\n          score += weight;\n          // Bonus se for match exato\n          if (strValue === searchQuery) {\n            score += weight * 2;\n          }\n        }\n      }\n    });\n    \n    return { item, score };\n  });\n  \n  // Filtra apenas com score > 0 e ordena\n  return scored\n    .filter(({ score }) => score > 0)\n    .sort((a, b) => b.score - a.score)\n    .map(({ item }) => item);\n}\n\n/**\n * Busca fuzzy (tolerante a erros de digitação)\n *\n * Usa distância de Levenshtein simplificada para encontrar\n * correspondências aproximadas.\n *\n * @param query - Termo de busca\n * @param content - Array de objetos a buscar\n * @param options - Opções de busca + threshold\n * @returns Array com correspondências aproximadas\n *\n * @example\n * ```ts\n * fuzzySearch('nxt', posts) // Encontra 'next'\n * fuzzySearch('raect', posts) // Encontra 'react'\n * ```\n */\nexport function fuzzySearch<T extends Record<string, any>>(\n  query: string,\n  content: T[],\n  options: SearchOptions & { threshold?: number } = {}\n): T[] {\n  if (!query.trim()) return content;\n  \n  const {\n    fields = ['title', 'description'],\n    caseSensitive = false,\n    threshold = 0.6 // Similaridade mínima (0-1)\n  } = options;\n  \n  const searchQuery = caseSensitive ? query : query.toLowerCase();\n  \n  return content.filter(item => {\n    return fields.some(field => {\n      const value = item[field];\n      if (!value) return false;\n      \n      const strValue = caseSensitive ? String(value) : String(value).toLowerCase();\n      const similarity = calculateSimilarity(searchQuery, strValue);\n      \n      return similarity >= threshold;\n    });\n  });\n}\n\n/**\n * Calcula similaridade entre duas strings (0-1)\n * Usa algoritmo de Jaro-Winkler simplificado\n */\nfunction calculateSimilarity(str1: string, str2: string): number {\n  if (str1 === str2) return 1;\n  if (str1.length === 0 || str2.length === 0) return 0;\n  \n  // Busca substring\n  if (str2.includes(str1)) return 0.8;\n  \n  // Calcula caracteres em comum\n  const common = str1.split('').filter(char => str2.includes(char)).length;\n  const similarity = common / Math.max(str1.length, str2.length);\n  \n  return similarity;\n}\n"]}